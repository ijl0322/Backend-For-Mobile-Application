# User Tracker 

## Useful Links

Home: https://usertracker-164618.appspot.com

Getting Today's Summary: https://usertracker-164618.appspot.com/dailySummary/ 

Manually Sending a Summary Email to Developer: https://usertracker-164618.appspot.com/summaryEmail/

Viewing the Touch Heat Map: https://usertracker-164618.appspot.com/touchChart/show/

Clearing Touch Poing Values: https://usertracker-164618.appspot.com/touchChart/clear/


## Introduction:
The user tracker was designed to track the user's usage of an app, including session time/ events / touches...
The companion app Koi Pond was designed to facilitate the testing of the backend server.

### Koi Pond
When Koi Pond becomes active, it records its session start time in a singlton named ActionTracker. It also saves touch points, and button click information in this singleton. When the app is about to become inactive, it sends out a json in a POST request to https://usertracker-164618.appspot.com. Sample json format: 

```json
{
  "date" : {
    "year" : 2017,
    "month" : 4,
    "day" : 16
  },
  "user" : "abc",
  "touches" : [
    {
      "y" : 493.6665649414062,
      "x" : 103.3333282470703
    },
    {
      "y" : 484.6665954589844,
      "x" : 103.3333282470703
    },
  ],
  "sessionTime" : 1588.391999006271,
  "events" : {
    "button1" : 5,
    "button2" : 5
  }
}
```
Note: The value of "user" is the UIDevice().identifierForVendor?.uuidString of each iOS devices. Here I'm using "abc" as an example.

### User tracker server
When the server receives this POST request, the request is received by the MainPage handler, and it updates the database accordingly. 
## Implementation Detail of the Server - Models
### UserHash 
Keeps track of two values:

	user_list => A list of users that have used the app (not just TODAY)
	new_user_count => Number of users who only started using this app TODAY 
	(more about this in DailyActivityRecords)

This is used to track whether a user is a new user. Since my app does not require log in, I decided that it was unnessasary to store each user as one entity. The information of all existing users are stored as a list, but sharding is applied. When a user sends in data, its user name is hashed using a simple hash function. The hash value equals to : The total value of each ascii character in user id% 20.
This hash value is used as the key_id for sharding. Since the user id is unique, random, and does not change, this should give all 20 entities in the UserHash approximately the same amount of data. Also, we will not have to check all entities to decide whether a user is a new user, it is only neccessary to check the one entity with the key_id matching the user's hash value. 

### DailyActiveUserCounter
While the UserHash records all users that has ever used the app, the DailyActiveUserCounter only keeps count of users who used the app today. The sharding mechanism of this is the same as the UserHash.

### EventCounterShard
The event counter shard's keeps track of the following values: 

	session_count => Total Number of Sessions of the day
	session_length => Total Session Length of the day
	button1_count => Total Number of times button 1 has been clicked
	button2_count => Total Number of times button 2 has been clicked

This is also sharded.
When new json is received, a random key_id value between 0 ~ 19 is picked, and the values received are added to that entity. 

### TouchTracker
The TouchTracker keeps track of the following values: 

	touch_x = List of x points
	touch_y = List of y points
	The ith touch value is (touch_x[i], touch_y[i])

When a user uses an app, they generate much more touch point values than any other information in the EventCounterShard, and these values cannot be aggregated.
So I decided that it should have it's own model. 
This modle uses sharding and stores all user touch points.

To see a graph of all touch points: https://usertracker-164618.appspot.com/touchChart/show/

To clear out all touch information: https://usertracker-164618.appspot.com/touchChart/clear/

Note. I decided that keeping all the touch points in the database would be an inefficient use of memory, (used my app for about 60 seconds and got over 500 touches), and it would probably be sufficient to save the touchHeatMap generated by the https://usertracker-164618.appspot.com/touchChart/show/ when needed. As an result, when the information are cleared, they will be deleted from the database. 
Also, when the daily email is sent, a touch heat map will be sent to the developer, and all touch information will be erased. 

### DailyActivityRecords
The DailyActivityRecords keeps track of the following infomation:

	year => Today's year
	month => Today's month
	day => Today's date
	session_count => Total session today
	avg_session_length => Average session length today
	button1_count => Total number of times button 1 has been tapped today
	button2_count => Total number of times button 2 has been tapped today 
	daily_active_user_list => a list of usernames of today's active users (This is used to calculate monthly active users)
	daily_new_user => Number of users that started using the app today

When a day is over, there will never be any new data for that day, unless we somehow invent time machine. So everyday at 10 pm, before we send the summary to all developers, we gather all data from DailyActiveUserCounter, EventCounterShard, and new_user_count from UserHash. After all data are aggregated, A new entity will be added to DailyActivityRecords for future reference. Example:


The key_id of this entity will be 2017-04-16.

|Year | Month | Day | Session Count | Avg Session Length | Button1 | Button2 | Daily New User | Daily Active User List|              
|-----|-------|-----|---------------|--------------------|---------|---------|----------------|-----------------------|
|2017 |  04   |  16 |       120     |       120.35       |   157   |   203   |        5       | "abc", "cde", "def"...|
  
After this process is complete, all values in DailyActiveUserCounter, EventCounterShard, and new_user_count will be set to 0 or []. 
And they're ready to get values for a new day! 
Note: The user_list in UserHash remains intact, so that a new user today will not be a new user tomorrow!


This process can be done a couples of time manually by the developer. If the developer wishes to see the newest result, he/she simply needs to send a GET request to https://usertracker-164618.appspot.com/dailySummary/ 

Which will show the aggregated result on a web page. On the same day, the key_id will be the same, so values will be added to the correct entity set without problem.

## Testing 
To test uploading data using differet user id:
  ```
  KoiPond > ActionTracker.swift 
  Change the variable ID to any user ID that you would like to test
  ```
To test summarizing data for a different date (adding it to daily activity records):
  ```
  UserTracker > dailyActivityRecotds.py
  In the function update, change year, month, and date   
  year = now.year
  month = now.month
  day = now.day
  This will let you aggregate data from eventCounterShard and dailyActiveUserCouter into the entity of the date you
  specified. Thus allows you to test adding data to different dates. 
  ```
To test getting the summary data for a different date: (This will impact the data shown on the /dailySummary/ page and in the email)
  ```
  UserTracker > dailyActivityRecords.py
  In the function format_summary, change year, month, and date   
  year = now.year
  month = now.month
  day = now.day
  ```
## Attribution:
http://www.saltycrane.com/blog/2009/05/converting-time-zones-datetime-objects-python/
http://stackoverflow.com/questions/5466157/is-it-possible-to-save-a-google-chart-as-an-image

## Interesting Resource:
https://image-charts.com/documentation#!/chart/getChart
